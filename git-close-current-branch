#!/bin/bash

. "${BASH_SOURCE[0]%/*}"/utils.bash

usage() {
    echo "Usage: git close-current-branch [MAINLINE]"
    echo
    echo "Options:"
    echo "  -h --help  Displays this help."
    [[ -z $1 ]] && return
    echo
    echo "Description:"
    echo "  Closes the current branch if it's been merged into the mainline."
    echo "  The config key close-current-branch.mainline defines the default mainline"
    echo "  if not given as an argument, with 'develop' as the default if unset."
    echo
    echo "  This script is intended to be used after a pull request is merged and the"
    echo "  remote branch is closed."
    echo
    echo "Example:"
    echo "  > git fetch && git close-current-branch"
}

detectMainline() {
    local branch
    if ! branch=$(git config --get close-current-branch.mainline); then
        color yellow "warning:" reset " no mainline provided, assuming " cyan "develop" reset >&2
        color yellow "note:" reset " set config value " yellow "close-current-branch.mainline" reset " to suppress this warning" >&2
        branch=develop
    fi
    printf "%s\n" "$branch"
}

while (( $# > 0 )); do
    case "$1" in
        -h|--help)
            usage full
            exit
            ;;
        --)
            shift
            break
            ;;
        -*)
            die 2 "unknown flag $1" "$(usage)"
            ;;
        *)
            break
            ;;
    esac
    shift
done

mainline=$1
(( $# > 1 )) && die 2 "expected at most 1 parameter, found $#" "$(usage)"

git rev-parse --git-dir >/dev/null || exit

[[ -z $mainline ]] && { mainline=$(detectMainline) || exit; }
mainline=$(git rev-parse --revs-only --symbolic-full-name "$mainline" --) || exit
test -n "$mainline" || die "unknown branch '$mainline'"

HEAD=$(git rev-parse --revs-only --symbolic-full-name HEAD --) || exit
test "$HEAD" != "HEAD" || die "detached HEAD"
HEADcommit=
eval "$(git for-each-ref --count=1 --shell --format='
    HEADname=%(refname:short)
    HEADcommit=%(objectname)
    HEADupstream=%(upstream)
    HEADupstreamname=%(upstream:short)
' -- "$HEAD")"
test -n "$HEADcommit" || die 3 "couldn't find ref information for HEAD ($HEAD)"

ref=
eval "$(git for-each-ref --count=1 --shell --format='
    ref=%(refname)
    refname=%(refname:short)
    commit=%(objectname)
    upstream=%(upstream)
    upstreamname=%(upstream:short)
' -- "$mainline")"
test -n "$ref" || die "no such branch '$mainline'"
test "$ref" != "$HEAD" || die "$refname is currently checked out"

if ! git merge-base --is-ancestor "$HEADcommit" "$commit"; then
    # mainline does not contain our branch
    test -n "$upstream" || die "$refname does not contain HEAD"

    upstreamcommit=$(git rev-parse --verify "$upstream") || exit
    git merge-base --is-ancestor "$HEADcommit" "$upstreamcommit" ||
        die "neither $refname nor $upstreamname contain HEAD"

    # but upstream of mainline does
    color magenta "Updating" reset " mainline " cyan "$refname" reset " with " cyan "$upstreamname" reset "..."

    git merge-base --is-ancestor "$commit" "$upstreamcommit" ||
        die "$refname contains commits not found in $upstreamname"

    git update-ref -m "git close-current-branch" "$ref" "$upstreamcommit" "$commit" || exit
fi

color magenta "Checking out " cyan "$refname" reset "..."
git checkout "$refname" || exit

color magenta "Deleting " cyan "$HEADname" reset "..."
git update-ref -m "git close-current-branch" -d "$HEAD" "$HEADcommit" || exit

if test -n "$HEADupstream" && git rev-parse --quiet --verify "$HEADupstream" >/dev/null; then
    color yellow "warning:" reset " upstream " cyan "$HEADupstreamname" reset " still exists" >&2
fi
