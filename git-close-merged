#!/bin/bash

. "${BASH_SOURCE[0]%/*}"/utils.bash

usage() {
    echo "Usage: git close-merged [-f] [-u] [-n] [MAINLINE]"
    echo ""
    echo "-f --force     Close local branches even if upstream exists."
    echo "-u --upstream  Delete upstream branches if necessary."
    echo "               Note: you must pass -f as well to actually delete it,"
    echo "               otherwise it will only report whether it would have deleted"
    echo "               the branch."
    echo "-n --dry-run   Dry run; do not actually delete any branches."
}

opt_force=
opt_upstream=
opt_dry_run=

while (( $# > 0 )); do
    case "$1" in
        -h|--help)
            usage
            exit
            ;;
        -f|--force)
            opt_force=yes
            ;;
        -u|--upstream)
            opt_upstream=yes
            ;;
        -n|--dry-run)
            opt_dry_run=yes
            ;;
        --)
            shift
            break
            ;;
        -*)
            echo "unknown flag $1" &2
            usage >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
    shift
done

test -t 1
test -t 1 && colorFlags=-f || colorFlags=

mainline=${1-HEAD}
[[ -n $mainline ]] || die 2 "mainline branch cannot be ''" "$(usage)"
(( $# <= 1 )) || die 2 "expected at most 1 parameter, found $#" "$(usage)"

git rev-parse --git-dir >/dev/null || exit

mainline=$(git rev-parse --revs-only --symbolic-full-name "$mainline" --) || exit
[[ -n $mainline ]] || die "unknown branch '$mainline'"

mainlinecommit=
mainlineupstreamcommit=
eval "$(git for-each-ref --count=1 --shell --format='
    mainlinename=%(refname:short)
    mainlinecommit=%(objectname)
    mainlineupstream=%(upstream)
    mainlineupstreamname=%(upstream:short)
' -- "$mainline")"
[[ -n $mainlinecommit ]] || die 3 "couldn't find ref information for mainline ($mainline)"
if [[ -n $mainlineupstream ]]; then
    if ! mainlineupstreamcommit=$(git rev-parse --verify "$mainlineupstream"); then
        mainlineupstream=
    fi
fi

result=0
process_ref() {
    local ref=$1 refname=$2 commit=$3
    local upstream=$4 upstreamname=$5 upstreamcommit=
    local ishead=$6

    local notes=()
    local output=
    local remote= remoteref=

    local colorFlags=
    test -t 1 && colorFlags=-f

    local skip=
    if [[ $ref == "$mainline" ]]; then
        skip="mainline"
    elif [[ $ishead == '*' ]]; then
        skip="currently checked out"
    elif ! git merge-base --is-ancestor "$commit" "$mainlinecommit"; then
        if [[ -n $mainlineupstream ]] && git merge-base --is-ancestor "$commit" "$mainlineupstreamcommit"; then
            notes+=("$(color $colorFlags reset "branch is merged into mainline upstream " cyan "$mainlineupstreamname" reset)")
        else
            skip="contains unmerged commits"
        fi
    fi
    if [[ -n $skip ]]; then
        color green "Skipping" reset " " cyan "$refname" reset " ($skip)"
        return
    fi

    if [[ -n $upstream ]] && ! upstreamcommit=$(git rev-parse --quiet --verify "$upstream"); then
        upstream=
    fi

    color -n magenta "Deleting" reset " " cyan "$refname" reset "... "
    if [[ -n $upstream ]]; then
        if ! git merge-base --is-ancestor "$commit" "$upstreamcommit"; then
            color yellow "abort" reset
            color yellow "warning:" reset " branch " cyan "$refname" reset " contains commits not found in upstream " cyan "$upstreamname" reset
            return
        fi
        if [[ -n $opt_upstream ]]; then
            if ! git merge-base --is-ancestor "$upstreamcommit" "$mainlinecommit"; then
                color yellow "abort" reset
                color yellow "warning:" reset " upstream " cyan "$upstreamname" reset " contains unmerged commits"
                return
            fi
            # the remote used for the tracking branch comes from the config
            # branch.<branch>.remote.
            # Similarly the remote refspec is branch.<branch>.merge.
            # Our $upstream is the local remote-tracking branch, but the name may
            # differ from the remote refspec.
            if ! remote=$(git config --get branch."$refname".remote 2>/dev/null) \
                 remoteref=$(git config --get branch."$refname".merge 2>/dev/null); then
                # we got an upstream before but can't manually retrieve it now?
                color red "fail" reset
                color red "error:" reset " failed to retrieve upstream branch information"
                return
            fi
            if [[ -n $opt_force ]]; then
                local output=
                if [[ -n $opt_dry_run ]] || output=$(git push --delete --force-with-lease="$remoteref":"$upstreamcommit" "$remote" "$remoteref" 2>&1); then
                    notes+=("$(color $colorFlags reset "deleted upstream " cyan "$upstreamname" reset)")
                    [[ -n $output ]] && notes+=("$output")
                else
                    color red "fail" reset
                    color red "error:" reset " error deleting upstream " cyan "$upstreamname" reset
                    print_lines -h output -c yellow "$output"
                    result=1
                    return
                fi
            else
                color yellow "abort" reset
                color yellow "warning:" reset " pass -f to delete upstream " cyan "$upstreamname" reset
                return
            fi
        else
            color yellow "abort" reset
            color yellow "warning:" reset " upstream " cyan "$upstreamname" reset " still exists"
            echo "         pass -u to delete upstream or -f to force"
            return
        fi

    fi

    # shellcheck disable=SC2069
    local output=
    if [[ -n $opt_dry_run ]] || output=$(git update-ref -m 'git close-merged' -d "$ref" "$commit" 2>&1 >/dev/null); then
        if [[ -n $opt_dry_run ]]; then
            color yellow "dry run" reset
        else
            color green "ok" reset
        fi
        for note in "${notes[@]}"; do
            print_lines -h note -c yellow "$note"
        done
    else
        color red "fail" reset
        color red "error: " reset " error closing branch " cyan "$refname" reset
        print_lines -h output -c yellow "$output"
        result=1
    fi
}

eval "$(git for-each-ref --shell --format='
    process_ref %(refname) %(refname:short) %(objectname) %(upstream) %(upstream:short) %(HEAD)
' -- refs/heads)"

if [[ $result == 0 ]]; then
    if [[ -n $opt_dry_run ]]; then
        echo -n '[dry run] '
    fi
    echo "All merged branches have been closed"
else
    exit $result
fi
